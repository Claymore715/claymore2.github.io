<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-google-hack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/07/google-hack/" class="article-date">
  <time datetime="2020-08-07T02:16:04.000Z" itemprop="datePublished">2020-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/07/google-hack/">google hack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>vul—漏洞</p>
<p>poc—证明存不存在漏洞</p>
<p>exp—漏洞利用代demo</p>
<p>cve—漏洞编号，漏洞字典，国际上的</p>
<p>cnvd—漏洞编号，漏洞字典，咱们自己的</p>
<p>0day—没打补丁，没公开的漏洞</p>
<p>shellcode—也是一种payload</p>
<p> payload（有效攻击负载）是包含在你用于一次漏洞利用（exploit）中的ShellCode中的主要功能代码 </p>
<p>apt—Advanced Persistent Threat  高级可持续性攻击</p>
<p>owaspbwa，vulhub</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/07/google-hack/" data-id="ckfjo92550001ywelddbghu30" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cors" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/06/cors/" class="article-date">
  <time datetime="2020-08-06T03:49:03.000Z" itemprop="datePublished">2020-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/06/cors/">cors</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>面试问到数据交互的时候，经常会问跨域如何处理。大部分人都会回答JSONP，然后面试官紧接着就会问：“JSONP缺点是什么啊？”这个时候坑就来了，如果面试者说它支持GET方式，然后面试官就会追问，那如果POST方式发送请求怎么办？基础扎实一些的面试者会说，使用CORS跨域，不扎实的可能就摇摇头了。</p>
<p>这还没结束，如果公司比较正规或者很在乎技术功底，你面试的又是重要岗位，HR还想砍你的工资，就会再补一刀，CORS跨域有什么问题呢？这时候能回答上来的就没几个了，就算是你答出来兼容性不好，需要IE10+浏览器,对方依然有话说，那兼容性怎么处理呢？应试者就没话了，要么被Pass掉，即便留下来，谈工资的时候就没底气了。</p>
<p>CORS跨域实在是面试官pass一个人的利器。</p>
<p>为什么会这样呢？</p>
<p>1.遇到CORS请求的情况不多，开发者使用这个场景的很少，大部分都JSONP搞定了。</p>
<p>2.开发者自身技能不扎实，偷懒心态，平常没有意识和意愿去提升自己的技术水平。</p>
<p>3.相关的学习资料少、纯前端小白搭建可测试的环境难度大。</p>
<p>面对这条拦路虎，我们今天就彻底解决掉它，让它不再是我们的软肋，而是彰显我们技术实力的亮点。</p>
<p>首先，什么是CORS?</p>
<p><img src="https://cdn.segmentfault.com/v-5f0a9217/global/img/squares.svg" alt="图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。</span><br><span class="line">它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</span><br></pre></td></tr></table></figure>

<p>优缺点</p>
<p>优点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.支持POST以及所有HTTP请求</span><br><span class="line">2.安全性相对JSOP更高</span><br><span class="line">3.前端要做的事儿比较少</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.不兼容老版本浏览器，如IE9及其以下</span><br><span class="line">2.需要服务端支持</span><br><span class="line">3.使用起来稍微复杂了些</span><br></pre></td></tr></table></figure>

<p>怎么用？</p>
<p>前端部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;CORS跨域请求&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function createCORSRequest(method, url) &#123;</span><br><span class="line">            var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">            if (&quot;withCredentials&quot; in xhr) &#123;</span><br><span class="line">                xhr.open(method, url, true);</span><br><span class="line">            &#125; else if (typeof XDomainRequest !&#x3D; &quot;undefined&quot;) &#123;</span><br><span class="line">                xhr &#x3D; new XDomainRequest();</span><br><span class="line">                xhr.open(method, url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                xhr &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            return xhr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        window.onload &#x3D; function () &#123;</span><br><span class="line">            var oBtn &#x3D; document.getElementById(&#39;btn1&#39;);</span><br><span class="line">            oBtn.onclick &#x3D; function () &#123;</span><br><span class="line">                var xhr &#x3D; createCORSRequest(&quot;get&quot;, &quot;http:&#x2F;&#x2F;wpdic.com&#x2F;cors.php&quot;);</span><br><span class="line">                if (xhr) &#123;</span><br><span class="line">                    xhr.onload &#x3D; function () &#123;</span><br><span class="line">                        var json &#x3D; JSON.parse(xhr.responseText);</span><br><span class="line">                        alert(json.a);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    xhr.onerror &#x3D; function () &#123;</span><br><span class="line">                        alert(&#39;请求失败.&#39;);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    xhr.send();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;获取数据&quot; id&#x3D;&quot;btn1&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<p>1.上面代码兼容IE8,因为用了XDomainRequest</p>
<p>2.其它代码你就当成XMLHttpRequset用，别考虑什么2.0不2.0的</p>
<p>3.如果你想post数据，可以往 xhr.send()里面搞</p>
<p>4.这里不建议大家研究”simple methdod”之类的知识，代码弄懂了会用就行，遇到问题了再查也不晚</p>
<p>后台部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&#39;content-type:application:json;charset&#x3D;utf8&#39;);</span><br><span class="line">header(&#39;Access-Control-Allow-Origin:*&#39;);</span><br><span class="line">header(&#39;Access-Control-Allow-Methods:GET,POST&#39;);</span><br><span class="line">header(&#39;Access-Control-Allow-Credentials: true&#39;);</span><br><span class="line">header(&#39;Access-Control-Allow-Headers:x-requested-with,content-type&#39;);</span><br><span class="line">$str &#x3D; &#39;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;&#39;; </span><br><span class="line">echo $str;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<p>1.Access-Control-Allow-Origin: <em>表示允许任何域名跨域访问，如果需要指定某域名才允许跨域访问，只需把Access-Control-Allow-Origin:</em>改为Access-Control-Allow-Origin:允许的域名,实际工作也要这么做2.Access-Control-Allow-Methods:GET,POST 规定允许的方法，建议控制严格些，不要随意放开DELETE之类的权限</p>
<p>2.Access-Control-Allow-Credentials</p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>最后，面试常考问题：</p>
<p>CORS和JSONP的应用场景区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CORS要求浏览器(&gt;IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/06/cors/" data-id="ckfjo925c0005ywel3dvbat3z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-转义字符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/05/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/" class="article-date">
  <time datetime="2020-08-05T10:05:51.000Z" itemprop="datePublished">2020-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/05/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/">转义字符</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#include &lt;stdio.h&gt;</p>
<p>int main()<br>{ char s=’\x35’; //注意： \xhh为十六进制所代表的字符 （先转化为10进制，再对照ascll转化成字符） </p>
<p>printf(“%c”,s);//输出5（16进制的35等于10进制的53，ascll表中对应字符’5’）<br>return 0;<br> } </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/05/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/" data-id="ckfjo925a0004ywel5k50fpbg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-django" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/31/django/" class="article-date">
  <time datetime="2020-07-31T14:39:04.000Z" itemprop="datePublished">2020-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/31/django/">django</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  django-admin startproject 项目名  </p>
<p>一个项目由很多个应用组成的，每一个应用完成一个功能模块。</p>
<p>创建应用的命令如下：</p>
<p>python manage.py startapp 应用名</p>
<p>注意：创建应用时需要先进入项目目录。</p>
<p>运行： python manage.py runserver  </p>
<p>停止      ctrl c</p>
<p>安装</p>
<ol>
<li><p>在dos命令行中输入 pip 如下命令进行安装：</p>
<p>安装最新的版本的 Django 命令如下：</p>
<p>pip install django</p>
<p>安装 指定版本的 Django 命令如下：</p>
<p>pip install django==1.10.3</p>
</li>
</ol>
<ol start="2">
<li><p>使用 show 来查看当前安装的 django库</p>
<p>pip show django</p>
</li>
</ol>
<ol start="3">
<li><p>使用pip命令来 卸载 Django</p>
<p>pip uninstall django</p>
</li>
</ol>
<p> #代表网页中的一个位置，浏览器读取后就将该位置滚动到可视区域。在网页中为位置指定标识符方法有两个，一个是利用锚点，例如<a name='page1'></a>，另外可以使用id属性，例如<div id='page2'></div>。</p>
<p>   #是用来指导浏览器动作的，http请求中是不包括#部分的，不会发送到服务器端。因此改变location.hash部分，浏览器不会发送请求重新加载页面。</p>
<p>   但是改变location.hash会在浏览器的访问历史中增加一个记录，使用后退键时可以回到上一个浏览位置。利用这一点就可以解决ajax中无访问状态的问题，配合#和历史记录，就可以在无刷新的ajax中顺利往返于各个访问状态。</p>
<p><img src="C:%5CUsers%5Caaa%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200923211450992.png" alt="image-20200923211450992"></p>
<p>下面来比较window.location.href和window.locaiton.hash的区别。</p>
<p>​    （1）window.location.href</p>
<p>​        得到和使用的是完整的url，比如window.location.href=”<a href="http://www.baidu.com”表示的是重新定向，页面跳转" target="_blank" rel="noopener">www.baidu.com”表示的是重新定向，页面跳转</a></p>
<p>到新的页面。也可以通过window.location.href得到a标签的完整的href，比如<a href="#book">如果使用href，那</p>
<p>么可以得到完整的链接（url）</p>
<p>​    （2）window.location.hash</p>
<p>​        得到的是锚链接。相比如href,通过window.location.hash并不会跳转到新的链接，只会在当前链接里面</p>
<p>改变锚链。并且如果有<a href="#book">通过window.location.hash得不到完整的链接（URL），仅仅得到#book.</p>
<p>window.location.hash简单应用</p>
<p>一、#的涵义</p>
<p>#代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如，</p>
<p>　　http://www.example.com/index.html#print</p>
<p>就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。</p>
<p>为网页位置指定标识符，有两个方法。一是使用锚点，比如<a name="print"></a>，二是使用id属性，比如<div id="print" >。</p>
<p>二、HTTP请求不包括#</p>
<p>#是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括#。</p>
<p>比如，访问下面的网址，</p>
<p>　　<a href="http://www.example.com/index.html#print" target="_blank" rel="noopener">http://www.example.com/index.html#print</a></p>
<p>浏览器实际发出的请求是这样的：</p>
<p>　　GET /index.html HTTP/1.1</p>
<p>　　Host: <a href="http://www.example.com/" target="_blank" rel="noopener">www.example.com</a></p>
<p>可以看到，只是请求index.html，根本没有”#print”的部分。</p>
<p>三、#后的字符</p>
<p>在第一个#后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。</p>
<p>比如，下面URL的原意是指定一个颜色值：</p>
<p>　　<a href="http://www.example.com/?color=#fff" target="_blank" rel="noopener">http://www.example.com/?color=#fff</a></p>
<p>但是，浏览器实际发出的请求是：</p>
<p>　　GET /?color= HTTP/1.1</p>
<p>　　Host: <a href="http://www.example.com/" target="_blank" rel="noopener">www.example.com</a></p>
<p>可以看到，”#fff”被省略了。只有将#转码为%23，浏览器才会将其作为实义字符处理。也就是说，上面的网址应该被写成：</p>
<p>　　<a href="http://example.com/?color=%23fff" target="_blank" rel="noopener">http://example.com/?color=%23fff</a></p>
<p>四、改变#不触发网页重载</p>
<p>单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。</p>
<p>比如，从</p>
<p>　　<a href="http://www.example.com/index.html#location1" target="_blank" rel="noopener">http://www.example.com/index.html#location1</a></p>
<p>改成</p>
<p>　　<a href="http://www.example.com/index.html#location2" target="_blank" rel="noopener">http://www.example.com/index.html#location2</a></p>
<p>浏览器不会重新向服务器请求index.html。</p>
<p>五、改变#会改变浏览器的访问历史</p>
<p>每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。</p>
<p>这对于ajax应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。</p>
<p>值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。</p>
<p>六、window.location.hash读取#值</p>
<p>window.location.hash这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。</p>
<p>七、onhashchange事件</p>
<p>这是一个HTML 5新增的事件，当#值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。</p>
<p>它的使用方法有三种：</p>
<p>　　window.onhashchange = func;</p>
<p>　　&lt;body οnhashchange=”func();”&gt;</p>
<p>　　window.addEventListener(“hashchange”, func, false);</p>
<p>对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。</p>
<p>八、Google抓取#的机制</p>
<p>默认情况下，Google的网络蜘蛛忽视URL的#部分。</p>
<p>但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用”#!”，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。</p>
<p>比如，Google发现新版twitter的URL如下：</p>
<p>　　<a href="http://twitter.com/#!/username" target="_blank" rel="noopener">http://twitter.com/#!/username</a></p>
<p>就会自动抓取另一个URL：</p>
<p>　　<a href="http://twitter.com/?_escaped_fragment_=/username" target="_blank" rel="noopener">http://twitter.com/?_escaped_fragment_=/username</a></p>
<p>通过这种机制，Google就可以索引动态的Ajax内容。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/31/django/" data-id="ckfjo92580003ywel2kp533ij" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-在线算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/30/%E5%9C%A8%E7%BA%BF%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-07-30T02:30:59.000Z" itemprop="datePublished">2020-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/30/%E5%9C%A8%E7%BA%BF%E7%AE%97%E6%B3%95/">在线算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们常常会听到对于区间修改、区间查询等问题的处理时，大佬们口中说的“离线”，“在线”等名词，一开始自然是一脸蒙逼。</p>
<p><strong>在线</strong>和<strong>离线</strong>可以简单的理解为<strong>对于所有的操作是否需要读入完毕</strong>。</p>
<p>在线的要求是可以不用先知道所有的操作（类似询问、修改），边读入边执行，类似<strong>“走一步，做一步”</strong>的思想。</p>
<p>离线则与在线相反，要求必须知道所有的操作，类似<strong>“记录所有步，回头再做”</strong>的思想，一般用Query[]记录所有操作。</p>
<p>常见的在线算法：带有<strong>“可持久化”</strong>字样的（主席树（可持久化线段树）、可持久化字典树、etc），<del>其实正常写题时基本上都是在线的思路……</del></p>
<p>常见的离线算法：整体二分、陈丹琦（CDQ）分治、莫队算法</p>
<p>对于正常的题目来讲，两种算法其实都可以使用，经典的题目如：动态第K大问题（zoj 2112），解法有树套树（在线）和整体二分/CDQ分治（离线），但是区别在于：</p>
<p>在线算法的思路相对简单，而代码量大（如某些毒瘤题），容易爆栈，赛场上及其考验心态（<del>菜逼表示早就炸了</del>）</p>
<p>离线算法的思路相对复杂，而代码量小，建议选手多采用（毕竟代码越多，debug越困难）</p>
<p>在线算法（online algorithm）和离线算法（offline algorithm）</p>
<p>维基百科举了这样一个例子，选择排序是离线算法，而插入排序是在线算法。那就从这两个算法来看看在线算法和离线算法的区别。</p>
<p>选择排序是不断地从未排序的元素中找到最大（小）的元素放到排序序列的起始位置。</p>
<p>插入排序是不断将未排序的序列插入到有序的序列中，有序序列中的元素相对位置会在一定程度上被改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/30/%E5%9C%A8%E7%BA%BF%E7%AE%97%E6%B3%95/" data-id="ckfjo925d0006ywel139o46gz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python虚拟环境" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/" class="article-date">
  <time datetime="2020-07-10T12:37:03.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/">python虚拟环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>创建 python -m venv file_name</p>
<p>创建不同版本 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\aaa\AppData\Local\Programs\Python\Python35\python -m venv file_name</span><br></pre></td></tr></table></figure>

<p>进入虚拟环境  file_name\scripts\activate </p>
<p>退出虚拟环境 file_name\scripts\deactivate.bat</p>
<p>cmd.exe对话框中如何返回上一级，如何返回根目录?</p>
<p>返回上一级 输入 cd..   回车 </p>
<p>返回根目录 输入  cd\  回车 </p>
<p>使用 pip freeze 获取安装的 Python 包<br>有时，我们为了代码稳定、代码迁移等，需要获取当前 Python 工程依赖包的安装列表。这个列表要包括需要安装什么包、以及包的版本。这便是：requirements.txt。</p>
<p>pip 使用 requirements.txt 安装<br>输入命令：</p>
<p>pip install -r requirements.txt<br>1<br>即可安装 requirements.txt 中的所有包（指定版本）。</p>
<p>pip freeze<br>使用 pip freeze 会输出所有在本地已安装的包（但不包括 pip、wheel、setuptools 等自带包），若需要输出内容与 pip list 一致，需使用 pip freeze -all。</p>
<p>使用方法：</p>
<p>pip freeze &gt; requirements.txt<br>1<br>适用场合<br>由于 pip freeze 与 pip list 内容区别不大，所以，若想要用其作为工程依赖包列表，一定要配合 Python 虚拟环境 virtualenv 使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/" data-id="ckcrh5pct00057sel70zo8l70" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-gcc和make" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/gcc%E5%92%8Cmake/" class="article-date">
  <time datetime="2020-07-10T09:33:31.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/gcc%E5%92%8Cmake/">gcc和make</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。</p>
<p>2.当你的程序只有一个源文件时，直接就可以用gcc命令编译它。</p>
<p>3.但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大</p>
<p>4.所以出现了make工具<br>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。</p>
<p>5.makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。</p>
<p>6.makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。</p>
<p>7.makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。</p>
<p>8.这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。</p>
<p>9.可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。</p>
<p>10.到最后CMakeLists.txt文件谁写啊？亲，是你自己手写的。</p>
<p>11.当然如果你用IDE，类似VS这些一般它都能帮你弄好了，你只需要按一下那个三角形</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/gcc%E5%92%8Cmake/" data-id="ckcrh5pcn00027selamcl8c52" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-csdn缓存问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/csdn%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-07-10T00:59:07.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/csdn%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/">csdn缓存问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>打开网页html，删除这段</p>
<p>div style=”display:none;”<br>    &lt;img src=”<a href="https://blog.csdn.net/qq_41800366/article/details/86583789&quot;" target="_blank" rel="noopener">https://blog.csdn.net/qq_41800366/article/details/86583789&quot;</a> onerror=”setTimeout(function(){if(!/(csdn.net|iteye.com|baiducontent.com|googleusercontent.com|360webcache.com|sogoucdn.com|bingj.com|baidu.com)$/.test(window.location.hostname)){window.location.href=&quot;\x68\x74\x74\x70\x73\x3a\x2f\x2f\x77\x77\x77\x2e\x63\x73\x64\x6e\x2e\x6e\x65\x74&quot;}},3000);”</p>
<h1 id="解决CSDN博客文章-保存网页到本地后，页面显示不全的问题"><a href="#解决CSDN博客文章-保存网页到本地后，页面显示不全的问题" class="headerlink" title="解决CSDN博客文章 保存网页到本地后，页面显示不全的问题"></a>解决CSDN博客文章 保存网页到本地后，页面显示不全的问题</h1><p>在该文件夹下，执行下面的批处理（保存为.bat）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::清理<span class="selector-class">.js</span>文件</span><br><span class="line"><span class="selector-tag">del</span> *<span class="selector-class">.js</span>.下载</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/csdn%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" data-id="ckcrh5pbn00007sel0lsu771l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/08/git/" class="article-date">
  <time datetime="2020-07-08T14:06:22.000Z" itemprop="datePublished">2020-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/08/git/">Git远程操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014061202.jpg" alt="git"> </p>
<h2 id="一、git-clone"><a href="#一、git-clone" class="headerlink" title="一、git clone"></a>一、git clone</h2><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>比如，克隆jQuery的版本库。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:<span class="comment">//github.com/jquery/jquery.git</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为<code>git clone</code>命令的第二个参数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone http[s]:<span class="comment">//example.com/path/to/repo.git/</span></span><br><span class="line">$ git clone ssh:<span class="comment">//example.com/path/to/repo.git/</span></span><br><span class="line">$ git clone git:<span class="comment">//example.com/path/to/repo.git/</span></span><br><span class="line">$ git clone /opt/git/project.git </span><br><span class="line">$ git clone file:<span class="comment">///opt/git/project.git</span></span><br><span class="line">$ git clone ftp[s]:<span class="comment">//example.com/path/to/repo.git/</span></span><br><span class="line">$ git clone rsync:<span class="comment">//example.com/path/to/repo.git/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、git-remote"><a href="#二、git-remote" class="headerlink" title="二、git remote"></a>二、git remote</h2><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p>
<p>不带选项的时候，<code>git remote</code>命令列出所有远程主机。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用<code>-v</code>选项，可以参看远程主机的网址。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:jquery/jquery.git (fetch)</span><br><span class="line">origin  git@github.com:jquery/jquery.git (push)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>
<p>克隆版本库的时候，所使用的远程主机自动被Git命名为<code>origin</code>。如果想用其他的主机名，需要用<code>git clone</code>命令的<code>-o</code>选项指定。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -o jQuery https:<span class="comment">//github.com/jquery/jquery.git</span></span><br><span class="line">$ git remote</span><br><span class="line">jQuery</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p>
<p><code>git remote show</code>命令加上主机名，可以查看该主机的详细信息。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show &lt;主机名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>git remote add</code>命令用于添加远程主机。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;主机名&gt; &lt;网址&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>git remote rm</code>命令用于删除远程主机。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm &lt;主机名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>git remote rename</code>命令用于远程主机的改名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、git-fetch"><a href="#三、git-fetch" class="headerlink" title="三、git fetch"></a>三、git fetch</h2><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令将某个远程主机的更新，全部取回本地。</p>
<p><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>
<p>默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>比如，取回<code>origin</code>主机的<code>master</code>分支。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如<code>origin</code>主机的<code>master</code>，就要用<code>origin/master</code>读取。</p>
<p><code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。</p>
<p>取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，在<code>origin/master</code>的基础上，创建一个新分支。</p>
<p>此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line"># 或者</span><br><span class="line">$ git rebase origin/master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示在当前分支上，合并<code>origin/master</code>。</p>
<h2 id="四、git-pull"><a href="#四、git-pull" class="headerlink" title="四、git pull"></a>四、git pull</h2><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin next:master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin next</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再做<code>git merge</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">$ git merge origin/next</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p>
<p>Git也允许手动建立追踪关系。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream master origin/next</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。</p>
<p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”（remote-tracking branch）进行合并。</p>
<p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>
<p>如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。</p>
<p>但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull -p</span><br><span class="line"># 等同于下面的命令</span><br><span class="line">$ git fetch --prune origin </span><br><span class="line">$ git fetch -p</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="五、git-push"><a href="#五、git-push" class="headerlink" title="五、git push"></a>五、git push</h2><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>
<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。</p>
<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :master</span><br><span class="line"># 等同于</span><br><span class="line">$ git push origin --<span class="keyword">delete</span> master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示删除<code>origin</code>主机的<code>master</code>分支。</p>
<p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，将当前分支推送到<code>origin</code>主机的对应分支。</p>
<p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定<code>origin</code>为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p>
<p>不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用<code>git config</code>命令。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global push.default matching</span><br><span class="line"># 或者</span><br><span class="line">$ git config --global push.default simple</span><br></pre></td></tr></table></figure>
</blockquote>
<p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<code>--all</code>选项。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --all origin</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，将所有本地分支都推送到<code>origin</code>主机。</p>
<p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>--force</code>选项。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --force origin </span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令使用<code>--force</code>选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用<code>--force</code>选项。</p>
<p>最后，<code>git push</code>不会推送标签（tag），除非使用<code>--tags</code>选项。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="上传本地代码及更新代码到GitHub教程"><a href="#上传本地代码及更新代码到GitHub教程" class="headerlink" title="上传本地代码及更新代码到GitHub教程"></a>上传本地代码及更新代码到GitHub教程</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="上传本地代码"><a href="#上传本地代码" class="headerlink" title="上传本地代码"></a>上传本地代码</h2><h2 id="第一步：去github上创建自己的Repository，创建页面如下图所示："><a href="#第一步：去github上创建自己的Repository，创建页面如下图所示：" class="headerlink" title="第一步：去github上创建自己的Repository，创建页面如下图所示："></a>第一步：去github上创建自己的Repository，创建页面如下图所示：</h2><p><img src="https://images2017.cnblogs.com/blog/1249529/201710/1249529-20171025111734035-171097772.png" alt="img"></p>
<h2 id="红框为新建的仓库的https地址"><a href="#红框为新建的仓库的https地址" class="headerlink" title="红框为新建的仓库的https地址"></a>红框为新建的仓库的https地址</h2><p><img src="https://images2017.cnblogs.com/blog/1249529/201710/1249529-20171025111740348-1861677831.png" alt="img"></p>
<h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# Test&quot; &gt;&gt; README.md</span><br></pre></td></tr></table></figure>

<h2 id="第三步：建立git仓库"><a href="#第三步：建立git仓库" class="headerlink" title="第三步：建立git仓库"></a>第三步：建立git仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h2 id="第四步：将项目的所有文件添加到仓库中"><a href="#第四步：将项目的所有文件添加到仓库中" class="headerlink" title="第四步：将项目的所有文件添加到仓库中"></a>第四步：将项目的所有文件添加到仓库中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<h2 id="第五步："><a href="#第五步：" class="headerlink" title="第五步："></a>第五步：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure>

<h2 id="第六步：提交到仓库"><a href="#第六步：提交到仓库" class="headerlink" title="第六步：提交到仓库"></a>第六步：提交到仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;注释语句&quot;</span><br></pre></td></tr></table></figure>

<h2 id="第七步：将本地的仓库关联到GitHub，后面的https改成刚刚自己的地址，上面的红框处"><a href="#第七步：将本地的仓库关联到GitHub，后面的https改成刚刚自己的地址，上面的红框处" class="headerlink" title="第七步：将本地的仓库关联到GitHub，后面的https改成刚刚自己的地址，上面的红框处"></a>第七步：将本地的仓库关联到GitHub，后面的https改成刚刚自己的地址，上面的红框处</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;zlxzlxzlx&#x2F;Test.git</span><br></pre></td></tr></table></figure>

<h2 id="第八步：上传github之前pull一下"><a href="#第八步：上传github之前pull一下" class="headerlink" title="第八步：上传github之前pull一下"></a>第八步：上传github之前pull一下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<h2 id="第九步：上传代码到GitHub远程仓库"><a href="#第九步：上传代码到GitHub远程仓库" class="headerlink" title="第九步：上传代码到GitHub远程仓库"></a>第九步：上传代码到GitHub远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了。执行完后，如果没有异常，等待执行完就上传成功了。"><a href="#中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了。执行完后，如果没有异常，等待执行完就上传成功了。" class="headerlink" title="中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了。执行完后，如果没有异常，等待执行完就上传成功了。"></a>中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了。执行完后，如果没有异常，等待执行完就上传成功了。</h2><h2 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h2><h2 id="第一步：查看当前的git仓库状态，可以使用git-status"><a href="#第一步：查看当前的git仓库状态，可以使用git-status" class="headerlink" title="第一步：查看当前的git仓库状态，可以使用git status"></a>第一步：查看当前的git仓库状态，可以使用git status</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h2 id="第二步：更新全部"><a href="#第二步：更新全部" class="headerlink" title="第二步：更新全部"></a>第二步：更新全部</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure>

<h2 id="第三步：接着输入git-commit-m-“更新说明”"><a href="#第三步：接着输入git-commit-m-“更新说明”" class="headerlink" title="第三步：接着输入git commit -m “更新说明”"></a>第三步：接着输入git commit -m “更新说明”</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;更新说明&quot;</span><br></pre></td></tr></table></figure>

<h2 id="第四步：先git-pull-拉取当前分支最新代码"><a href="#第四步：先git-pull-拉取当前分支最新代码" class="headerlink" title="第四步：先git pull,拉取当前分支最新代码"></a>第四步：先git pull,拉取当前分支最新代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h2 id="第五步：push到远程master分支上"><a href="#第五步：push到远程master分支上" class="headerlink" title="第五步：push到远程master分支上"></a>第五步：push到远程master分支上</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>





<h1 id="如何在Github上给别人的项目贡献代码"><a href="#如何在Github上给别人的项目贡献代码" class="headerlink" title="如何在Github上给别人的项目贡献代码"></a>如何在Github上给别人的项目贡献代码</h1><ul>
<li><p>进入自己的主页，选择fork别人的项目（已修改过代码），然后点击</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1863913-4020d4095b1eb280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/309/format/webp" alt="img"></p>
<p>进入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pull request</span><br></pre></td></tr></table></figure>

<p>页面，确认提交的更改，确认无误后，开始填写说明。</p>
</li>
</ul>
<ul>
<li><p>如下，点击<code>create pull request</code>来填写说明</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1863913-3c2f8a9329096037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1020/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1863913-66be4191fdb268f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/968/format/webp" alt="img"></p>
</li>
</ul>
<h1 id="fork后如何同步-源库-的新更新内容"><a href="#fork后如何同步-源库-的新更新内容" class="headerlink" title="fork后如何同步 源库 的新更新内容"></a>fork后如何同步 源库 的新更新内容</h1><p><a href="https://blog.csdn.net/qq1332479771/article/details/56087333" target="_blank" rel="noopener">https://blog.csdn.net/qq1332479771/article/details/56087333</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/08/git/" data-id="ckcrh5pcx00067selau9tangn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/07/linux-1/" class="article-date">
  <time datetime="2020-07-07T10:12:54.000Z" itemprop="datePublished">2020-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/07/linux-1/">linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Linux文件系统中，有两个特殊的符号也可以表示目录：</p>
<ul>
<li>“.”表示当前目录</li>
<li>“..”表示当前目录的上一级目录</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/07/linux-1/" data-id="ckcrh5pc500017selgt4vceuv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/1/" rel="tag">1</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/1/" style="font-size: 10px;">1</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/17/Hill/">Hill</a>
          </li>
        
          <li>
            <a href="/2021/03/16/matrix/">matrix</a>
          </li>
        
          <li>
            <a href="/2020/11/22/tenserflow-python/">tenserflow+python</a>
          </li>
        
          <li>
            <a href="/2020/10/28/%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC/">国王的烦恼</a>
          </li>
        
          <li>
            <a href="/2020/10/25/%E5%9C%B0%E5%AE%AB/">地宫</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>